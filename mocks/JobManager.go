// Code generated by mockery v2.50.0. DO NOT EDIT.

package mocks

import (
	jobmgr "github.com/fyerfyer/fyer-scheduler/pkg/master/jobmgr"
	mock "github.com/stretchr/testify/mock"

	models "github.com/fyerfyer/fyer-scheduler/pkg/common/models"
)

// JobManager is an autogenerated mock type for the JobManager type
type JobManager struct {
	mock.Mock
}

type JobManager_Expecter struct {
	mock *mock.Mock
}

func (_m *JobManager) EXPECT() *JobManager_Expecter {
	return &JobManager_Expecter{mock: &_m.Mock}
}

// CancelJob provides a mock function with given fields: jobID, reason
func (_m *JobManager) CancelJob(jobID string, reason string) error {
	ret := _m.Called(jobID, reason)

	if len(ret) == 0 {
		panic("no return value specified for CancelJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(jobID, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_CancelJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelJob'
type JobManager_CancelJob_Call struct {
	*mock.Call
}

// CancelJob is a helper method to define mock.On call
//   - jobID string
//   - reason string
func (_e *JobManager_Expecter) CancelJob(jobID interface{}, reason interface{}) *JobManager_CancelJob_Call {
	return &JobManager_CancelJob_Call{Call: _e.mock.On("CancelJob", jobID, reason)}
}

func (_c *JobManager_CancelJob_Call) Run(run func(jobID string, reason string)) *JobManager_CancelJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *JobManager_CancelJob_Call) Return(_a0 error) *JobManager_CancelJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_CancelJob_Call) RunAndReturn(run func(string, string) error) *JobManager_CancelJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJob provides a mock function with given fields: job
func (_m *JobManager) CreateJob(job *models.Job) error {
	ret := _m.Called(job)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.Job) error); ok {
		r0 = rf(job)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type JobManager_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - job *models.Job
func (_e *JobManager_Expecter) CreateJob(job interface{}) *JobManager_CreateJob_Call {
	return &JobManager_CreateJob_Call{Call: _e.mock.On("CreateJob", job)}
}

func (_c *JobManager_CreateJob_Call) Run(run func(job *models.Job)) *JobManager_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Job))
	})
	return _c
}

func (_c *JobManager_CreateJob_Call) Return(_a0 error) *JobManager_CreateJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_CreateJob_Call) RunAndReturn(run func(*models.Job) error) *JobManager_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJob provides a mock function with given fields: jobID
func (_m *JobManager) DeleteJob(jobID string) error {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_DeleteJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJob'
type JobManager_DeleteJob_Call struct {
	*mock.Call
}

// DeleteJob is a helper method to define mock.On call
//   - jobID string
func (_e *JobManager_Expecter) DeleteJob(jobID interface{}) *JobManager_DeleteJob_Call {
	return &JobManager_DeleteJob_Call{Call: _e.mock.On("DeleteJob", jobID)}
}

func (_c *JobManager_DeleteJob_Call) Run(run func(jobID string)) *JobManager_DeleteJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JobManager_DeleteJob_Call) Return(_a0 error) *JobManager_DeleteJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_DeleteJob_Call) RunAndReturn(run func(string) error) *JobManager_DeleteJob_Call {
	_c.Call.Return(run)
	return _c
}

// DisableJob provides a mock function with given fields: jobID
func (_m *JobManager) DisableJob(jobID string) error {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for DisableJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_DisableJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableJob'
type JobManager_DisableJob_Call struct {
	*mock.Call
}

// DisableJob is a helper method to define mock.On call
//   - jobID string
func (_e *JobManager_Expecter) DisableJob(jobID interface{}) *JobManager_DisableJob_Call {
	return &JobManager_DisableJob_Call{Call: _e.mock.On("DisableJob", jobID)}
}

func (_c *JobManager_DisableJob_Call) Run(run func(jobID string)) *JobManager_DisableJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JobManager_DisableJob_Call) Return(_a0 error) *JobManager_DisableJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_DisableJob_Call) RunAndReturn(run func(string) error) *JobManager_DisableJob_Call {
	_c.Call.Return(run)
	return _c
}

// EnableJob provides a mock function with given fields: jobID
func (_m *JobManager) EnableJob(jobID string) error {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for EnableJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_EnableJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableJob'
type JobManager_EnableJob_Call struct {
	*mock.Call
}

// EnableJob is a helper method to define mock.On call
//   - jobID string
func (_e *JobManager_Expecter) EnableJob(jobID interface{}) *JobManager_EnableJob_Call {
	return &JobManager_EnableJob_Call{Call: _e.mock.On("EnableJob", jobID)}
}

func (_c *JobManager_EnableJob_Call) Run(run func(jobID string)) *JobManager_EnableJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JobManager_EnableJob_Call) Return(_a0 error) *JobManager_EnableJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_EnableJob_Call) RunAndReturn(run func(string) error) *JobManager_EnableJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetDueJobs provides a mock function with no fields
func (_m *JobManager) GetDueJobs() ([]*models.Job, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetDueJobs")
	}

	var r0 []*models.Job
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]*models.Job, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []*models.Job); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Job)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JobManager_GetDueJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDueJobs'
type JobManager_GetDueJobs_Call struct {
	*mock.Call
}

// GetDueJobs is a helper method to define mock.On call
func (_e *JobManager_Expecter) GetDueJobs() *JobManager_GetDueJobs_Call {
	return &JobManager_GetDueJobs_Call{Call: _e.mock.On("GetDueJobs")}
}

func (_c *JobManager_GetDueJobs_Call) Run(run func()) *JobManager_GetDueJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JobManager_GetDueJobs_Call) Return(_a0 []*models.Job, _a1 error) *JobManager_GetDueJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JobManager_GetDueJobs_Call) RunAndReturn(run func() ([]*models.Job, error)) *JobManager_GetDueJobs_Call {
	_c.Call.Return(run)
	return _c
}

// GetJob provides a mock function with given fields: jobID
func (_m *JobManager) GetJob(jobID string) (*models.Job, error) {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJob")
	}

	var r0 *models.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*models.Job, error)); ok {
		return rf(jobID)
	}
	if rf, ok := ret.Get(0).(func(string) *models.Job); ok {
		r0 = rf(jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JobManager_GetJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJob'
type JobManager_GetJob_Call struct {
	*mock.Call
}

// GetJob is a helper method to define mock.On call
//   - jobID string
func (_e *JobManager_Expecter) GetJob(jobID interface{}) *JobManager_GetJob_Call {
	return &JobManager_GetJob_Call{Call: _e.mock.On("GetJob", jobID)}
}

func (_c *JobManager_GetJob_Call) Run(run func(jobID string)) *JobManager_GetJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JobManager_GetJob_Call) Return(_a0 *models.Job, _a1 error) *JobManager_GetJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JobManager_GetJob_Call) RunAndReturn(run func(string) (*models.Job, error)) *JobManager_GetJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobs provides a mock function with given fields: page, pageSize
func (_m *JobManager) ListJobs(page int64, pageSize int64) ([]*models.Job, int64, error) {
	ret := _m.Called(page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListJobs")
	}

	var r0 []*models.Job
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(int64, int64) ([]*models.Job, int64, error)); ok {
		return rf(page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(int64, int64) []*models.Job); ok {
		r0 = rf(page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(int64, int64) int64); ok {
		r1 = rf(page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(int64, int64) error); ok {
		r2 = rf(page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// JobManager_ListJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobs'
type JobManager_ListJobs_Call struct {
	*mock.Call
}

// ListJobs is a helper method to define mock.On call
//   - page int64
//   - pageSize int64
func (_e *JobManager_Expecter) ListJobs(page interface{}, pageSize interface{}) *JobManager_ListJobs_Call {
	return &JobManager_ListJobs_Call{Call: _e.mock.On("ListJobs", page, pageSize)}
}

func (_c *JobManager_ListJobs_Call) Run(run func(page int64, pageSize int64)) *JobManager_ListJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int64))
	})
	return _c
}

func (_c *JobManager_ListJobs_Call) Return(_a0 []*models.Job, _a1 int64, _a2 error) *JobManager_ListJobs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *JobManager_ListJobs_Call) RunAndReturn(run func(int64, int64) ([]*models.Job, int64, error)) *JobManager_ListJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ListJobsByStatus provides a mock function with given fields: status, page, pageSize
func (_m *JobManager) ListJobsByStatus(status string, page int64, pageSize int64) ([]*models.Job, int64, error) {
	ret := _m.Called(status, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListJobsByStatus")
	}

	var r0 []*models.Job
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) ([]*models.Job, int64, error)); ok {
		return rf(status, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) []*models.Job); ok {
		r0 = rf(status, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) int64); ok {
		r1 = rf(status, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, int64, int64) error); ok {
		r2 = rf(status, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// JobManager_ListJobsByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListJobsByStatus'
type JobManager_ListJobsByStatus_Call struct {
	*mock.Call
}

// ListJobsByStatus is a helper method to define mock.On call
//   - status string
//   - page int64
//   - pageSize int64
func (_e *JobManager_Expecter) ListJobsByStatus(status interface{}, page interface{}, pageSize interface{}) *JobManager_ListJobsByStatus_Call {
	return &JobManager_ListJobsByStatus_Call{Call: _e.mock.On("ListJobsByStatus", status, page, pageSize)}
}

func (_c *JobManager_ListJobsByStatus_Call) Run(run func(status string, page int64, pageSize int64)) *JobManager_ListJobsByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *JobManager_ListJobsByStatus_Call) Return(_a0 []*models.Job, _a1 int64, _a2 error) *JobManager_ListJobsByStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *JobManager_ListJobsByStatus_Call) RunAndReturn(run func(string, int64, int64) ([]*models.Job, int64, error)) *JobManager_ListJobsByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with no fields
func (_m *JobManager) Start() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type JobManager_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
func (_e *JobManager_Expecter) Start() *JobManager_Start_Call {
	return &JobManager_Start_Call{Call: _e.mock.On("Start")}
}

func (_c *JobManager_Start_Call) Run(run func()) *JobManager_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JobManager_Start_Call) Return(_a0 error) *JobManager_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_Start_Call) RunAndReturn(run func() error) *JobManager_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with no fields
func (_m *JobManager) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type JobManager_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *JobManager_Expecter) Stop() *JobManager_Stop_Call {
	return &JobManager_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *JobManager_Stop_Call) Run(run func()) *JobManager_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JobManager_Stop_Call) Return(_a0 error) *JobManager_Stop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_Stop_Call) RunAndReturn(run func() error) *JobManager_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// TriggerJob provides a mock function with given fields: jobID
func (_m *JobManager) TriggerJob(jobID string) error {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for TriggerJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_TriggerJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerJob'
type JobManager_TriggerJob_Call struct {
	*mock.Call
}

// TriggerJob is a helper method to define mock.On call
//   - jobID string
func (_e *JobManager_Expecter) TriggerJob(jobID interface{}) *JobManager_TriggerJob_Call {
	return &JobManager_TriggerJob_Call{Call: _e.mock.On("TriggerJob", jobID)}
}

func (_c *JobManager_TriggerJob_Call) Run(run func(jobID string)) *JobManager_TriggerJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *JobManager_TriggerJob_Call) Return(_a0 error) *JobManager_TriggerJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_TriggerJob_Call) RunAndReturn(run func(string) error) *JobManager_TriggerJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJob provides a mock function with given fields: job
func (_m *JobManager) UpdateJob(job *models.Job) error {
	ret := _m.Called(job)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.Job) error); ok {
		r0 = rf(job)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JobManager_UpdateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJob'
type JobManager_UpdateJob_Call struct {
	*mock.Call
}

// UpdateJob is a helper method to define mock.On call
//   - job *models.Job
func (_e *JobManager_Expecter) UpdateJob(job interface{}) *JobManager_UpdateJob_Call {
	return &JobManager_UpdateJob_Call{Call: _e.mock.On("UpdateJob", job)}
}

func (_c *JobManager_UpdateJob_Call) Run(run func(job *models.Job)) *JobManager_UpdateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Job))
	})
	return _c
}

func (_c *JobManager_UpdateJob_Call) Return(_a0 error) *JobManager_UpdateJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JobManager_UpdateJob_Call) RunAndReturn(run func(*models.Job) error) *JobManager_UpdateJob_Call {
	_c.Call.Return(run)
	return _c
}

// WatchJobChanges provides a mock function with given fields: handler
func (_m *JobManager) WatchJobChanges(handler jobmgr.JobChangeHandler) {
	_m.Called(handler)
}

// JobManager_WatchJobChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchJobChanges'
type JobManager_WatchJobChanges_Call struct {
	*mock.Call
}

// WatchJobChanges is a helper method to define mock.On call
//   - handler jobmgr.JobChangeHandler
func (_e *JobManager_Expecter) WatchJobChanges(handler interface{}) *JobManager_WatchJobChanges_Call {
	return &JobManager_WatchJobChanges_Call{Call: _e.mock.On("WatchJobChanges", handler)}
}

func (_c *JobManager_WatchJobChanges_Call) Run(run func(handler jobmgr.JobChangeHandler)) *JobManager_WatchJobChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(jobmgr.JobChangeHandler))
	})
	return _c
}

func (_c *JobManager_WatchJobChanges_Call) Return() *JobManager_WatchJobChanges_Call {
	_c.Call.Return()
	return _c
}

func (_c *JobManager_WatchJobChanges_Call) RunAndReturn(run func(jobmgr.JobChangeHandler)) *JobManager_WatchJobChanges_Call {
	_c.Run(run)
	return _c
}

// NewJobManager creates a new instance of JobManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewJobManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *JobManager {
	mock := &JobManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
