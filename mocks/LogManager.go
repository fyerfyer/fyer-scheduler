// Code generated by mockery v2.50.0. DO NOT EDIT.

package mocks

import (
	io "io"

	mock "github.com/stretchr/testify/mock"

	models "github.com/fyerfyer/fyer-scheduler/pkg/common/models"

	time "time"
)

// LogManager is an autogenerated mock type for the LogManager type
type LogManager struct {
	mock.Mock
}

type LogManager_Expecter struct {
	mock *mock.Mock
}

func (_m *LogManager) EXPECT() *LogManager_Expecter {
	return &LogManager_Expecter{mock: &_m.Mock}
}

// AppendOutput provides a mock function with given fields: executionID, output
func (_m *LogManager) AppendOutput(executionID string, output string) error {
	ret := _m.Called(executionID, output)

	if len(ret) == 0 {
		panic("no return value specified for AppendOutput")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(executionID, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_AppendOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendOutput'
type LogManager_AppendOutput_Call struct {
	*mock.Call
}

// AppendOutput is a helper method to define mock.On call
//   - executionID string
//   - output string
func (_e *LogManager_Expecter) AppendOutput(executionID interface{}, output interface{}) *LogManager_AppendOutput_Call {
	return &LogManager_AppendOutput_Call{Call: _e.mock.On("AppendOutput", executionID, output)}
}

func (_c *LogManager_AppendOutput_Call) Run(run func(executionID string, output string)) *LogManager_AppendOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *LogManager_AppendOutput_Call) Return(_a0 error) *LogManager_AppendOutput_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_AppendOutput_Call) RunAndReturn(run func(string, string) error) *LogManager_AppendOutput_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupOldLogs provides a mock function with given fields: beforeTime
func (_m *LogManager) CleanupOldLogs(beforeTime time.Time) (int64, error) {
	ret := _m.Called(beforeTime)

	if len(ret) == 0 {
		panic("no return value specified for CleanupOldLogs")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time) (int64, error)); ok {
		return rf(beforeTime)
	}
	if rf, ok := ret.Get(0).(func(time.Time) int64); ok {
		r0 = rf(beforeTime)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(time.Time) error); ok {
		r1 = rf(beforeTime)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_CleanupOldLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupOldLogs'
type LogManager_CleanupOldLogs_Call struct {
	*mock.Call
}

// CleanupOldLogs is a helper method to define mock.On call
//   - beforeTime time.Time
func (_e *LogManager_Expecter) CleanupOldLogs(beforeTime interface{}) *LogManager_CleanupOldLogs_Call {
	return &LogManager_CleanupOldLogs_Call{Call: _e.mock.On("CleanupOldLogs", beforeTime)}
}

func (_c *LogManager_CleanupOldLogs_Call) Run(run func(beforeTime time.Time)) *LogManager_CleanupOldLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time))
	})
	return _c
}

func (_c *LogManager_CleanupOldLogs_Call) Return(_a0 int64, _a1 error) *LogManager_CleanupOldLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_CleanupOldLogs_Call) RunAndReturn(run func(time.Time) (int64, error)) *LogManager_CleanupOldLogs_Call {
	_c.Call.Return(run)
	return _c
}

// GetDailyJobExecutionStats provides a mock function with given fields: days
func (_m *LogManager) GetDailyJobExecutionStats(days int) ([]map[string]interface{}, error) {
	ret := _m.Called(days)

	if len(ret) == 0 {
		panic("no return value specified for GetDailyJobExecutionStats")
	}

	var r0 []map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]map[string]interface{}, error)); ok {
		return rf(days)
	}
	if rf, ok := ret.Get(0).(func(int) []map[string]interface{}); ok {
		r0 = rf(days)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(days)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetDailyJobExecutionStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDailyJobExecutionStats'
type LogManager_GetDailyJobExecutionStats_Call struct {
	*mock.Call
}

// GetDailyJobExecutionStats is a helper method to define mock.On call
//   - days int
func (_e *LogManager_Expecter) GetDailyJobExecutionStats(days interface{}) *LogManager_GetDailyJobExecutionStats_Call {
	return &LogManager_GetDailyJobExecutionStats_Call{Call: _e.mock.On("GetDailyJobExecutionStats", days)}
}

func (_c *LogManager_GetDailyJobExecutionStats_Call) Run(run func(days int)) *LogManager_GetDailyJobExecutionStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *LogManager_GetDailyJobExecutionStats_Call) Return(_a0 []map[string]interface{}, _a1 error) *LogManager_GetDailyJobExecutionStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetDailyJobExecutionStats_Call) RunAndReturn(run func(int) ([]map[string]interface{}, error)) *LogManager_GetDailyJobExecutionStats_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobStatusCounts provides a mock function with given fields: jobID
func (_m *LogManager) GetJobStatusCounts(jobID string) (map[string]int64, error) {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStatusCounts")
	}

	var r0 map[string]int64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (map[string]int64, error)); ok {
		return rf(jobID)
	}
	if rf, ok := ret.Get(0).(func(string) map[string]int64); ok {
		r0 = rf(jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetJobStatusCounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobStatusCounts'
type LogManager_GetJobStatusCounts_Call struct {
	*mock.Call
}

// GetJobStatusCounts is a helper method to define mock.On call
//   - jobID string
func (_e *LogManager_Expecter) GetJobStatusCounts(jobID interface{}) *LogManager_GetJobStatusCounts_Call {
	return &LogManager_GetJobStatusCounts_Call{Call: _e.mock.On("GetJobStatusCounts", jobID)}
}

func (_c *LogManager_GetJobStatusCounts_Call) Run(run func(jobID string)) *LogManager_GetJobStatusCounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LogManager_GetJobStatusCounts_Call) Return(_a0 map[string]int64, _a1 error) *LogManager_GetJobStatusCounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetJobStatusCounts_Call) RunAndReturn(run func(string) (map[string]int64, error)) *LogManager_GetJobStatusCounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobSuccessRate provides a mock function with given fields: jobID, period
func (_m *LogManager) GetJobSuccessRate(jobID string, period time.Duration) (float64, error) {
	ret := _m.Called(jobID, period)

	if len(ret) == 0 {
		panic("no return value specified for GetJobSuccessRate")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(string, time.Duration) (float64, error)); ok {
		return rf(jobID, period)
	}
	if rf, ok := ret.Get(0).(func(string, time.Duration) float64); ok {
		r0 = rf(jobID, period)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(string, time.Duration) error); ok {
		r1 = rf(jobID, period)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetJobSuccessRate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobSuccessRate'
type LogManager_GetJobSuccessRate_Call struct {
	*mock.Call
}

// GetJobSuccessRate is a helper method to define mock.On call
//   - jobID string
//   - period time.Duration
func (_e *LogManager_Expecter) GetJobSuccessRate(jobID interface{}, period interface{}) *LogManager_GetJobSuccessRate_Call {
	return &LogManager_GetJobSuccessRate_Call{Call: _e.mock.On("GetJobSuccessRate", jobID, period)}
}

func (_c *LogManager_GetJobSuccessRate_Call) Run(run func(jobID string, period time.Duration)) *LogManager_GetJobSuccessRate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(time.Duration))
	})
	return _c
}

func (_c *LogManager_GetJobSuccessRate_Call) Return(_a0 float64, _a1 error) *LogManager_GetJobSuccessRate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetJobSuccessRate_Call) RunAndReturn(run func(string, time.Duration) (float64, error)) *LogManager_GetJobSuccessRate_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestLogByJobID provides a mock function with given fields: jobID
func (_m *LogManager) GetLatestLogByJobID(jobID string) (*models.JobLog, error) {
	ret := _m.Called(jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestLogByJobID")
	}

	var r0 *models.JobLog
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*models.JobLog, error)); ok {
		return rf(jobID)
	}
	if rf, ok := ret.Get(0).(func(string) *models.JobLog); ok {
		r0 = rf(jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetLatestLogByJobID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestLogByJobID'
type LogManager_GetLatestLogByJobID_Call struct {
	*mock.Call
}

// GetLatestLogByJobID is a helper method to define mock.On call
//   - jobID string
func (_e *LogManager_Expecter) GetLatestLogByJobID(jobID interface{}) *LogManager_GetLatestLogByJobID_Call {
	return &LogManager_GetLatestLogByJobID_Call{Call: _e.mock.On("GetLatestLogByJobID", jobID)}
}

func (_c *LogManager_GetLatestLogByJobID_Call) Run(run func(jobID string)) *LogManager_GetLatestLogByJobID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LogManager_GetLatestLogByJobID_Call) Return(_a0 *models.JobLog, _a1 error) *LogManager_GetLatestLogByJobID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetLatestLogByJobID_Call) RunAndReturn(run func(string) (*models.JobLog, error)) *LogManager_GetLatestLogByJobID_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogByExecutionID provides a mock function with given fields: executionID
func (_m *LogManager) GetLogByExecutionID(executionID string) (*models.JobLog, error) {
	ret := _m.Called(executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetLogByExecutionID")
	}

	var r0 *models.JobLog
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (*models.JobLog, error)); ok {
		return rf(executionID)
	}
	if rf, ok := ret.Get(0).(func(string) *models.JobLog); ok {
		r0 = rf(executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(executionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetLogByExecutionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogByExecutionID'
type LogManager_GetLogByExecutionID_Call struct {
	*mock.Call
}

// GetLogByExecutionID is a helper method to define mock.On call
//   - executionID string
func (_e *LogManager_Expecter) GetLogByExecutionID(executionID interface{}) *LogManager_GetLogByExecutionID_Call {
	return &LogManager_GetLogByExecutionID_Call{Call: _e.mock.On("GetLogByExecutionID", executionID)}
}

func (_c *LogManager_GetLogByExecutionID_Call) Run(run func(executionID string)) *LogManager_GetLogByExecutionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LogManager_GetLogByExecutionID_Call) Return(_a0 *models.JobLog, _a1 error) *LogManager_GetLogByExecutionID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetLogByExecutionID_Call) RunAndReturn(run func(string) (*models.JobLog, error)) *LogManager_GetLogByExecutionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsByJobID provides a mock function with given fields: jobID, page, pageSize
func (_m *LogManager) GetLogsByJobID(jobID string, page int64, pageSize int64) ([]*models.JobLog, int64, error) {
	ret := _m.Called(jobID, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsByJobID")
	}

	var r0 []*models.JobLog
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) ([]*models.JobLog, int64, error)); ok {
		return rf(jobID, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) []*models.JobLog); ok {
		r0 = rf(jobID, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) int64); ok {
		r1 = rf(jobID, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, int64, int64) error); ok {
		r2 = rf(jobID, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LogManager_GetLogsByJobID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsByJobID'
type LogManager_GetLogsByJobID_Call struct {
	*mock.Call
}

// GetLogsByJobID is a helper method to define mock.On call
//   - jobID string
//   - page int64
//   - pageSize int64
func (_e *LogManager_Expecter) GetLogsByJobID(jobID interface{}, page interface{}, pageSize interface{}) *LogManager_GetLogsByJobID_Call {
	return &LogManager_GetLogsByJobID_Call{Call: _e.mock.On("GetLogsByJobID", jobID, page, pageSize)}
}

func (_c *LogManager_GetLogsByJobID_Call) Run(run func(jobID string, page int64, pageSize int64)) *LogManager_GetLogsByJobID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *LogManager_GetLogsByJobID_Call) Return(_a0 []*models.JobLog, _a1 int64, _a2 error) *LogManager_GetLogsByJobID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *LogManager_GetLogsByJobID_Call) RunAndReturn(run func(string, int64, int64) ([]*models.JobLog, int64, error)) *LogManager_GetLogsByJobID_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsByStatus provides a mock function with given fields: status, page, pageSize
func (_m *LogManager) GetLogsByStatus(status string, page int64, pageSize int64) ([]*models.JobLog, int64, error) {
	ret := _m.Called(status, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsByStatus")
	}

	var r0 []*models.JobLog
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) ([]*models.JobLog, int64, error)); ok {
		return rf(status, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) []*models.JobLog); ok {
		r0 = rf(status, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) int64); ok {
		r1 = rf(status, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, int64, int64) error); ok {
		r2 = rf(status, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LogManager_GetLogsByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsByStatus'
type LogManager_GetLogsByStatus_Call struct {
	*mock.Call
}

// GetLogsByStatus is a helper method to define mock.On call
//   - status string
//   - page int64
//   - pageSize int64
func (_e *LogManager_Expecter) GetLogsByStatus(status interface{}, page interface{}, pageSize interface{}) *LogManager_GetLogsByStatus_Call {
	return &LogManager_GetLogsByStatus_Call{Call: _e.mock.On("GetLogsByStatus", status, page, pageSize)}
}

func (_c *LogManager_GetLogsByStatus_Call) Run(run func(status string, page int64, pageSize int64)) *LogManager_GetLogsByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *LogManager_GetLogsByStatus_Call) Return(_a0 []*models.JobLog, _a1 int64, _a2 error) *LogManager_GetLogsByStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *LogManager_GetLogsByStatus_Call) RunAndReturn(run func(string, int64, int64) ([]*models.JobLog, int64, error)) *LogManager_GetLogsByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsByTimeRange provides a mock function with given fields: startTime, endTime, page, pageSize
func (_m *LogManager) GetLogsByTimeRange(startTime time.Time, endTime time.Time, page int64, pageSize int64) ([]*models.JobLog, int64, error) {
	ret := _m.Called(startTime, endTime, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsByTimeRange")
	}

	var r0 []*models.JobLog
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, int64, int64) ([]*models.JobLog, int64, error)); ok {
		return rf(startTime, endTime, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(time.Time, time.Time, int64, int64) []*models.JobLog); ok {
		r0 = rf(startTime, endTime, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, time.Time, int64, int64) int64); ok {
		r1 = rf(startTime, endTime, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(time.Time, time.Time, int64, int64) error); ok {
		r2 = rf(startTime, endTime, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LogManager_GetLogsByTimeRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsByTimeRange'
type LogManager_GetLogsByTimeRange_Call struct {
	*mock.Call
}

// GetLogsByTimeRange is a helper method to define mock.On call
//   - startTime time.Time
//   - endTime time.Time
//   - page int64
//   - pageSize int64
func (_e *LogManager_Expecter) GetLogsByTimeRange(startTime interface{}, endTime interface{}, page interface{}, pageSize interface{}) *LogManager_GetLogsByTimeRange_Call {
	return &LogManager_GetLogsByTimeRange_Call{Call: _e.mock.On("GetLogsByTimeRange", startTime, endTime, page, pageSize)}
}

func (_c *LogManager_GetLogsByTimeRange_Call) Run(run func(startTime time.Time, endTime time.Time, page int64, pageSize int64)) *LogManager_GetLogsByTimeRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time), args[1].(time.Time), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *LogManager_GetLogsByTimeRange_Call) Return(_a0 []*models.JobLog, _a1 int64, _a2 error) *LogManager_GetLogsByTimeRange_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *LogManager_GetLogsByTimeRange_Call) RunAndReturn(run func(time.Time, time.Time, int64, int64) ([]*models.JobLog, int64, error)) *LogManager_GetLogsByTimeRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogsByWorkerID provides a mock function with given fields: workerID, page, pageSize
func (_m *LogManager) GetLogsByWorkerID(workerID string, page int64, pageSize int64) ([]*models.JobLog, int64, error) {
	ret := _m.Called(workerID, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for GetLogsByWorkerID")
	}

	var r0 []*models.JobLog
	var r1 int64
	var r2 error
	if rf, ok := ret.Get(0).(func(string, int64, int64) ([]*models.JobLog, int64, error)); ok {
		return rf(workerID, page, pageSize)
	}
	if rf, ok := ret.Get(0).(func(string, int64, int64) []*models.JobLog); ok {
		r0 = rf(workerID, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.JobLog)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int64, int64) int64); ok {
		r1 = rf(workerID, page, pageSize)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(string, int64, int64) error); ok {
		r2 = rf(workerID, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LogManager_GetLogsByWorkerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogsByWorkerID'
type LogManager_GetLogsByWorkerID_Call struct {
	*mock.Call
}

// GetLogsByWorkerID is a helper method to define mock.On call
//   - workerID string
//   - page int64
//   - pageSize int64
func (_e *LogManager_Expecter) GetLogsByWorkerID(workerID interface{}, page interface{}, pageSize interface{}) *LogManager_GetLogsByWorkerID_Call {
	return &LogManager_GetLogsByWorkerID_Call{Call: _e.mock.On("GetLogsByWorkerID", workerID, page, pageSize)}
}

func (_c *LogManager_GetLogsByWorkerID_Call) Run(run func(workerID string, page int64, pageSize int64)) *LogManager_GetLogsByWorkerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *LogManager_GetLogsByWorkerID_Call) Return(_a0 []*models.JobLog, _a1 int64, _a2 error) *LogManager_GetLogsByWorkerID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *LogManager_GetLogsByWorkerID_Call) RunAndReturn(run func(string, int64, int64) ([]*models.JobLog, int64, error)) *LogManager_GetLogsByWorkerID_Call {
	_c.Call.Return(run)
	return _c
}

// GetSystemStatusSummary provides a mock function with no fields
func (_m *LogManager) GetSystemStatusSummary() (map[string]interface{}, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSystemStatusSummary")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string]interface{}, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string]interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_GetSystemStatusSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSystemStatusSummary'
type LogManager_GetSystemStatusSummary_Call struct {
	*mock.Call
}

// GetSystemStatusSummary is a helper method to define mock.On call
func (_e *LogManager_Expecter) GetSystemStatusSummary() *LogManager_GetSystemStatusSummary_Call {
	return &LogManager_GetSystemStatusSummary_Call{Call: _e.mock.On("GetSystemStatusSummary")}
}

func (_c *LogManager_GetSystemStatusSummary_Call) Run(run func()) *LogManager_GetSystemStatusSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LogManager_GetSystemStatusSummary_Call) Return(_a0 map[string]interface{}, _a1 error) *LogManager_GetSystemStatusSummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_GetSystemStatusSummary_Call) RunAndReturn(run func() (map[string]interface{}, error)) *LogManager_GetSystemStatusSummary_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with no fields
func (_m *LogManager) Start() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type LogManager_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
func (_e *LogManager_Expecter) Start() *LogManager_Start_Call {
	return &LogManager_Start_Call{Call: _e.mock.On("Start")}
}

func (_c *LogManager_Start_Call) Run(run func()) *LogManager_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LogManager_Start_Call) Return(_a0 error) *LogManager_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_Start_Call) RunAndReturn(run func() error) *LogManager_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with no fields
func (_m *LogManager) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type LogManager_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *LogManager_Expecter) Stop() *LogManager_Stop_Call {
	return &LogManager_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *LogManager_Stop_Call) Run(run func()) *LogManager_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *LogManager_Stop_Call) Return(_a0 error) *LogManager_Stop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_Stop_Call) RunAndReturn(run func() error) *LogManager_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// StreamLogOutput provides a mock function with given fields: executionID, writer
func (_m *LogManager) StreamLogOutput(executionID string, writer io.Writer) error {
	ret := _m.Called(executionID, writer)

	if len(ret) == 0 {
		panic("no return value specified for StreamLogOutput")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, io.Writer) error); ok {
		r0 = rf(executionID, writer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_StreamLogOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamLogOutput'
type LogManager_StreamLogOutput_Call struct {
	*mock.Call
}

// StreamLogOutput is a helper method to define mock.On call
//   - executionID string
//   - writer io.Writer
func (_e *LogManager_Expecter) StreamLogOutput(executionID interface{}, writer interface{}) *LogManager_StreamLogOutput_Call {
	return &LogManager_StreamLogOutput_Call{Call: _e.mock.On("StreamLogOutput", executionID, writer)}
}

func (_c *LogManager_StreamLogOutput_Call) Run(run func(executionID string, writer io.Writer)) *LogManager_StreamLogOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(io.Writer))
	})
	return _c
}

func (_c *LogManager_StreamLogOutput_Call) Return(_a0 error) *LogManager_StreamLogOutput_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_StreamLogOutput_Call) RunAndReturn(run func(string, io.Writer) error) *LogManager_StreamLogOutput_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToLogUpdates provides a mock function with given fields: executionID
func (_m *LogManager) SubscribeToLogUpdates(executionID string) (<-chan string, error) {
	ret := _m.Called(executionID)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToLogUpdates")
	}

	var r0 <-chan string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (<-chan string, error)); ok {
		return rf(executionID)
	}
	if rf, ok := ret.Get(0).(func(string) <-chan string); ok {
		r0 = rf(executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(executionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogManager_SubscribeToLogUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToLogUpdates'
type LogManager_SubscribeToLogUpdates_Call struct {
	*mock.Call
}

// SubscribeToLogUpdates is a helper method to define mock.On call
//   - executionID string
func (_e *LogManager_Expecter) SubscribeToLogUpdates(executionID interface{}) *LogManager_SubscribeToLogUpdates_Call {
	return &LogManager_SubscribeToLogUpdates_Call{Call: _e.mock.On("SubscribeToLogUpdates", executionID)}
}

func (_c *LogManager_SubscribeToLogUpdates_Call) Run(run func(executionID string)) *LogManager_SubscribeToLogUpdates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LogManager_SubscribeToLogUpdates_Call) Return(_a0 <-chan string, _a1 error) *LogManager_SubscribeToLogUpdates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *LogManager_SubscribeToLogUpdates_Call) RunAndReturn(run func(string) (<-chan string, error)) *LogManager_SubscribeToLogUpdates_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromLogUpdates provides a mock function with given fields: executionID
func (_m *LogManager) UnsubscribeFromLogUpdates(executionID string) error {
	ret := _m.Called(executionID)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromLogUpdates")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(executionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_UnsubscribeFromLogUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromLogUpdates'
type LogManager_UnsubscribeFromLogUpdates_Call struct {
	*mock.Call
}

// UnsubscribeFromLogUpdates is a helper method to define mock.On call
//   - executionID string
func (_e *LogManager_Expecter) UnsubscribeFromLogUpdates(executionID interface{}) *LogManager_UnsubscribeFromLogUpdates_Call {
	return &LogManager_UnsubscribeFromLogUpdates_Call{Call: _e.mock.On("UnsubscribeFromLogUpdates", executionID)}
}

func (_c *LogManager_UnsubscribeFromLogUpdates_Call) Run(run func(executionID string)) *LogManager_UnsubscribeFromLogUpdates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *LogManager_UnsubscribeFromLogUpdates_Call) Return(_a0 error) *LogManager_UnsubscribeFromLogUpdates_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_UnsubscribeFromLogUpdates_Call) RunAndReturn(run func(string) error) *LogManager_UnsubscribeFromLogUpdates_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLogStatus provides a mock function with given fields: executionID, status, output
func (_m *LogManager) UpdateLogStatus(executionID string, status string, output string) error {
	ret := _m.Called(executionID, status, output)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLogStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(executionID, status, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogManager_UpdateLogStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLogStatus'
type LogManager_UpdateLogStatus_Call struct {
	*mock.Call
}

// UpdateLogStatus is a helper method to define mock.On call
//   - executionID string
//   - status string
//   - output string
func (_e *LogManager_Expecter) UpdateLogStatus(executionID interface{}, status interface{}, output interface{}) *LogManager_UpdateLogStatus_Call {
	return &LogManager_UpdateLogStatus_Call{Call: _e.mock.On("UpdateLogStatus", executionID, status, output)}
}

func (_c *LogManager_UpdateLogStatus_Call) Run(run func(executionID string, status string, output string)) *LogManager_UpdateLogStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *LogManager_UpdateLogStatus_Call) Return(_a0 error) *LogManager_UpdateLogStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *LogManager_UpdateLogStatus_Call) RunAndReturn(run func(string, string, string) error) *LogManager_UpdateLogStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewLogManager creates a new instance of LogManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLogManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *LogManager {
	mock := &LogManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
